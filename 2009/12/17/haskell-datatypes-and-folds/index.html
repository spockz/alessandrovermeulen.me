
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Haskell Datatypes and Folds: Part I - Alessandro Vermeulen</title>
  <meta name="author" content="Alessandro Vermeulen">

  
  <meta name="description" content="Welcome to this little explanation on how to determine the fold of a Haskell
datatype. First we’ll look at how we define functions over lists, &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://alessandrovermeulen.me/2009/12/17/haskell-datatypes-and-folds">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <!--<script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>-->
  <link href="/atom.xml" rel="alternate" title="Alessandro Vermeulen" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!-- <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->
<!-- <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->
<!-- <script src="http://cachedcommons.org/javascripts/jquery/jquery.disqus.js" type="text/javascript"></script> -->
<link href='http://fonts.googleapis.com/css?family=Open+Sans|Droid+Serif' rel='stylesheet' type='text/css'>

</head>

<body   >

  <section class="container">
    <header role="banner"><hgroup>
  <header id="pageheader">
    <header role="banner" id="banner">
      <h1><a href="/">Alessandro Vermeulen</a></h1>
      
        <p>Alessandro Vermeulen's blog about languages, programming, Computer Science, photography and the Web. <a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS"><i class="icon-rss"></i></a></p>
      
    </header>
  </header>
</hgroup>

</header>
    <nav role="navigation"><nav class="navbar">
  <ul class="nav nav-pills">
  <li><a href="/about">About</a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>


  <ul class="pull-right subscription nav nav-pills" data-subscription="rss">
  
  </ul>

  <form class="navbar-search pull-right" action="http://google.com/search" method="get">
  <fieldset role="search" id="searchfieldset">
    <input type="hidden" name="q" value="site:alessandrovermeulen.me" />

    <div class="input-append">
      <input class="search" type="text" name="q" results="0" placeholder="Search"/>
      <button type="submit" class="btn"><i class="icon-search"></i></button>
    </div>
  </fieldset>
  </form>
</nav>
<!--
<ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:alessandrovermeulen.me" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>

 --></nav>
    <!--[if lt IE 9]>
    <div class="alert alert-block">
      <button type="button" class="close" data-dismiss="alert">&times;</button>
      <h4>Warning!</h4>
      Your version of Internet Explorer is seriously outdated. Please upgrade to a decent version of <a href="http://windows.microsoft.com/en-us/internet-explorer/download-ie">Internet Explorer</a> or <a href="http://www.google.com/chrome">Chrome</a> or <a href="http://www.mozilla.org/en-US/firefox/new/">Firefox</a>.
    </div>
    <![endif]-->
    <div id="main">
      <div id="content">
        <div class="row-fluid">
  <div class="span9">
  <article class="hentry" role="article">
    
  <header>
    
      <h1 class="entry-title">Haskell Datatypes and Folds: Part I</h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-12-17T00:00:00+00:00" pubdate data-updated="true">Dec 17<span>th</span>, 2009</time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>Welcome to this little explanation on how to determine the fold of a Haskell
datatype. First we’ll look at how we define functions over lists, something
everyone starting with Haskell should be sufficiently familiar with, after which
we move on to the datatypes. You’ll see different ways how to calculate the sum
of a list, how to fold over a list, what datatypes are and, how to fold over a
datatype, specifically the <code>BinTree a</code> datatype. Most importantly, I hope you
will grow to understand what a fold is, and why they are so important and useful
when programming Haskell.</p>

<p>During our functional programming course at Utrecht University I noticed
students having anxiety of datatypes and even more for folds. Not because they
couldn’t grasp the workings of a single example but more a lack of a view on the
complete picture and lack of experience with the Haskell datatype way.</p>

<p>So, what are datatypes? Datatypes are a way of notating the abstract structure
of your data. There are several datastructures known to man, such as lists and
trees.</p>
<h3>Lists</h3>
<p>Lists in Haskell are used in several ways. Today we will look at how to
calculate the sum of a list. Intuitively you calculate the sum of a list by
adding its elements together. Starting with the first element and then
continuing on to the rest. This is how we literally translate that thought into
Haskell code:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">sum</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class="line"><span class="nf">sum</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="mi">0</span>
</span><span class="line"><span class="nf">sum</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sum</span> <span class="n">xs</span>
</span><span class="line"><span class="c1">-- sum [1..4] = 10</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Would we be calculating the product of the list, we’d do the same except we
multiply instead of adding.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">product</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class="line"><span class="nf">product</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="mi">1</span>
</span><span class="line"><span class="nf">product</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">product</span> <span class="n">xs</span>
</span><span class="line"><span class="c1">-- product [1..4] = 24</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Looking at these two examples we can see that we have two similarities. We
always have recursion on the tail of the list and we do something with the head
of the list and the result of the recursion. In the first example we add them
together, and in product we multiply them. Another property of most functions
over lists is that there is a base case for the empty list. We call this the
<em>identity</em> of our function, sometimes also referred to as <em>unit</em>.
The identity of addition is 0 and the identity of multiplication is 1.</p>

<p>Now we look at one of the folds over lists defined in the prelude,
<code>foldr</code>. Make sure you know what each parameter stands for.
<strong>Note:</strong> There are some downsides to this function, mostly that it
will not work for large lists, you’ll see more on this later.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">foldr</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</span><span class="line"><span class="nf">foldr</span> <span class="n">f</span> <span class="n">z</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="n">z</span>
</span><span class="line"><span class="nf">foldr</span> <span class="n">f</span> <span class="n">z</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="p">(</span><span class="n">foldr</span> <span class="n">f</span> <span class="n">z</span> <span class="n">xs</span><span class="p">)</span>
</span><span class="line"><span class="c1">-- The line above can also be written as:</span>
</span><span class="line"><span class="c1">-- foldr f z (x:xs) = x `f` (foldr f z xs)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Now, take a moment to let this function soak in and try to think of how you
would define <code>sum</code> and <code>product</code> in terms of this
<code>foldr</code>. Crucial at this point is to notice that we do not see any
type hardcoded in the type of <code>foldr</code> It may be helpful to look at
this fold, which is the identity function for lists:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">idList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</span><span class="line"><span class="nf">idList</span> <span class="n">list</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="kt">:</span><span class="p">)</span> <span class="kt">[]</span> <span class="n">list</span>
</span><span class="line"><span class="c1">-- Recall: [1,2,3,4,5] == 1 : 2 : 3 : 4 : 5 : []</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>If we look at our sum function, the operator between each recursive call is
<code>(+)</code> and our base case is 0. So that’s what we are going to use for
our sum in terms of foldr.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">sumList</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class="line"><span class="nf">sumList</span> <span class="n">list</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="n">list</span>
</span><span class="line"><span class="c1">-- sumList [1..4] = 10</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Thus far we only have lists of <code>Int</code> for our examples. However, for
sake of usability we will now move on to lists of numeric elements. Because
<code>(+)</code> is defined for all numbers. (If you wish to read more on this
subject please look up classes and instances.) Notice how the type of sumList
changes while it’s definition remains unaltered.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">sumList</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span><span class="line"><span class="nf">sumList</span> <span class="n">list</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="n">list</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Now that we have seen how we can determine the function and identity for our
fold from our recursive function to a definition in terms of <code>foldr</code>.
And most importantly, the foldr takes care of the recursive nature of the list
for us and the only thing it asks us in return for that is an operator and an
identity for your operation. So the fold can now be used to define several
operations on lists.</p>

<p>I told you about a problem of <code>foldr</code>. Depending on the size of your
list the above <code>sumList</code> may not work. Try the following on your
machine:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="nv">$ </span>ghci
</span><span class="line">Prelude&gt; <span class="nb">let </span><span class="nv">sumList</span> <span class="o">=</span> foldr <span class="o">(</span>+<span class="o">)</span> 0
</span><span class="line">Prelude&gt; sumList <span class="o">[</span>1..1000000<span class="o">]</span>
</span><span class="line">*** Exception: stack overflow
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Now try:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="nv">$ </span>ghci
</span><span class="line">Prelude&gt; <span class="nb">let </span><span class="nv">sumList</span> <span class="o">=</span> Data.List.foldl<span class="err">&#39;</span> <span class="o">(</span>+<span class="o">)</span> 0
</span><span class="line">Prelude&gt; sumList <span class="o">[</span>1..1000000<span class="o">]</span>
</span><span class="line">500000500000
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>For a complete overview and analysis on <code>foldr</code> and
<code>foldl</code> please read <a href="http://www.cs.nott.ac.uk/~gmh/fold.pdf">A tutorial on the universality and
expressiveness of fold</a>, by Graham Hutton.</p>

<h3>Trees</h3>
<p>First, let’s take a look at how data structures in Haskell can be defined. In
short we have the <code>data</code> keyword, followed by zero or more <code>type
variables</code>, a <code>=</code> and then a number of <code>data
constructors</code> separated by a <code>|</code>.</p>

<p>Now that you have familiarized yourself with lists we can proceed to a slightly
more complicated datastructure. The Tree. In this example we will use a simple
binary tree. A binary tree can be denoted as follows:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">BinTree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="kt">BinTree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">BinTree</span> <span class="n">a</span><span class="p">)</span> <span class="o">|</span> <span class="kt">Leaf</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>In this case <code>BinTree</code> is the <em>type constructor</em> and
<code>Node</code> and <code>Leaf</code> the data <em>data constructors</em>.</p>

<p>Remember that the goal of folds is to separate the implementation of the
recursion from the actual operation we want to execute on the datatype. So we
have one function, the <em>fold</em>, that takes care of the recursion and
several other functions that use this fold to specify certain semantics on the
datatype. We are going to calculate the sum of all elements in this tree.</p>

<p>The above binary tree has elements in the nodes and nothing in the leaves. You
can notice the recursive occurrence of &#8220;BinTree a<code>' in the node. We
see two constructors in this datatype, </code>Node<code> and </code>Leaf<code>.
The Node constructor expects some value of type </code>a<code> and two subtrees
of type </code>BinTree a<code>, and the </code>Leaf` constructor has no
parameters. In Haskell:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kt">Node</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">BinTree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">BinTree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">BinTree</span> <span class="n">a</span>
</span><span class="line"><span class="kt">Leaf</span> <span class="ow">::</span> <span class="kt">BinTree</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Notice that our list also has two constructors, namely the <code>(:)</code>
constructor that adds an element and the constructor for the empty list,
<code>[]</code>. Analogously we have the <code>Node</code> and <code>Leaf</code>
constructors. If we were allowed to use the <code>(:)</code> and <code>[]</code>
constructor in our own Haskell code, the datatype for a list would look like
this:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">:</span><span class="p">)</span> <span class="n">a</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span> <span class="o">|</span> <span class="kt">[]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Also, it is customary to keep the arguments for the functions in the same order
as the constructors are defined in the datatype, and to name the identifiers
containing the functions the same as the constructor function but in lowercase.
Applying this we get:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">foldBinTree</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">BinTree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">BinTree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">BinTree</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">BinTree</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">BinTree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="o">??</span>
</span><span class="line"><span class="nf">foldBinTree</span> <span class="n">node</span> <span class="n">leaf</span> <span class="ow">=</span> <span class="n">f</span>
</span><span class="line">  <span class="kr">where</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">x</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span> <span class="ow">=</span> <span class="n">node</span> <span class="n">x</span> <span class="p">(</span><span class="n">f</span> <span class="n">left</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">right</span><span class="p">)</span>
</span><span class="line">        <span class="n">f</span> <span class="p">(</span><span class="kt">Leaf</span><span class="p">)</span>              <span class="ow">=</span> <span class="n">leaf</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>I left out the result type of this fold, try to find it yourself before
continuing.</p>

<p>By following our code we can see that every case, the case for <code>Node</code>
and the one for <code>Leaf</code>, result in a <code>BinTree a</code>.
Consequently the complete result of the function is a <code>BinTree a</code></p>

<p>Now recall that we previously used a fold to calculate the sum of a list. With
that fold we were not restricted to a list. Which is also clearly visible by
looking at the type of <code>foldr</code> it contains only type variables. As we
want to calculate sum of the elements in this tree, which is something of type
<code>a</code> and not of type <code>BinTree a</code> we have to revise the type
of our fold. Notice the recurrence of the datatype in it’s declaration,
<code>BinTree a</code>. We will replace all of these occurrences in the types of
our functions with a free type variable, say <code>r</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">foldBinTree</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">r</span> <span class="ow">-&gt;</span> <span class="n">r</span> <span class="ow">-&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">BinTree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">r</span>
</span><span class="line"><span class="nf">foldBinTree</span> <span class="n">node</span> <span class="n">leaf</span> <span class="ow">=</span> <span class="n">f</span>
</span><span class="line">  <span class="kr">where</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">x</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span> <span class="ow">=</span> <span class="n">node</span> <span class="n">x</span> <span class="p">(</span><span class="n">f</span> <span class="n">left</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">right</span><span class="p">)</span>
</span><span class="line">        <span class="n">f</span> <span class="p">(</span><span class="kt">Leaf</span><span class="p">)</span>              <span class="ow">=</span> <span class="n">leaf</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Keep in mind that I used ‘eta reduction’ in the above code. This means that the
last parameter (in this case the tree) isn’t explicitly specified as it would
appear at the very end of the parameter list and ath the very end of the
definition. (<a href="http://www.haskell.org/haskellwiki/Eta_conversion">More on
eta reduction</a>.) So, now let’s do something with this fold. Suppose we have
the following tree:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">bintree</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="mi">1</span>
</span><span class="line">            <span class="p">(</span><span class="kt">Node</span> <span class="mi">2</span>
</span><span class="line">              <span class="p">(</span><span class="kt">Node</span> <span class="mi">3</span> <span class="kt">Leaf</span> <span class="kt">Leaf</span><span class="p">)</span>
</span><span class="line">              <span class="p">(</span><span class="kt">Node</span> <span class="mi">3</span> <span class="kt">Leaf</span> <span class="kt">Leaf</span><span class="p">)</span>
</span><span class="line">            <span class="p">)</span>
</span><span class="line">            <span class="p">(</span><span class="kt">Node</span> <span class="mi">2</span>
</span><span class="line">              <span class="p">(</span><span class="kt">Node</span> <span class="mi">3</span> <span class="kt">Leaf</span> <span class="kt">Leaf</span><span class="p">)</span>
</span><span class="line">              <span class="p">(</span><span class="kt">Node</span> <span class="mi">3</span> <span class="kt">Leaf</span> <span class="kt">Leaf</span><span class="p">)</span>
</span><span class="line">            <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>A visual representation:</p>
<pre>            1
          /  \
         2    2
        / \  / \
       3   3 3  3</pre>
<p>Now we can define several traversals over this tree. Let’s calculate the sum of
all values in the tree.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">sumBinTree</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">BinTree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span><span class="line"><span class="nf">sumBinTree</span> <span class="ow">=</span> <span class="n">foldBinTree</span> <span class="p">(</span><span class="nf">\</span><span class="n">val</span> <span class="n">res_left</span> <span class="n">res_right</span> <span class="ow">-&gt;</span> <span class="n">val</span> <span class="o">+</span> <span class="n">res_left</span> <span class="o">+</span> <span class="n">res_right</span><span class="p">)</span>
</span><span class="line">                         <span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<h4>Algebras</h4>
<p>The type of our foldBinTree is now more compact. However, there will be
datatypes that contain a larger sum of constructors that also may have more or
less parameters than in our case. Defining the type of the fold on those
datatypes as we have done before will inevitably lead to very clumsy type
signatures. The idea is that we split up the section that denotes our functions
into a separate type, namely the <em>algebra</em>.</p>

<p>So now we define an algebra for our data structure. To do this we again look at
each data constructor and determine it’s type. The fold function takes care of
the recursion, so applying this thought consequently gives us the following
types and fold.</p>

<p>Keep in mind that we have to change the type of our fold, but not the definition
of the fold itself!</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">type</span> <span class="kt">BinTreeAlgebra</span> <span class="n">a</span> <span class="n">r</span> <span class="ow">=</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">r</span> <span class="ow">-&gt;</span> <span class="n">r</span> <span class="ow">-&gt;</span> <span class="n">r</span><span class="p">,</span> <span class="c1">-- Node</span>
</span><span class="line">                           <span class="n">r</span> <span class="c1">-- Leaf</span>
</span><span class="line">                          <span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">foldBinTree</span> <span class="ow">::</span> <span class="kt">BinTreeAlgebra</span> <span class="n">a</span> <span class="n">r</span> <span class="ow">-&gt;</span> <span class="kt">BinTree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">r</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Now we can again define a sum on all <code>Num a</code> trees. Notice that we
went from to seperate parameters for the functions to one tuple with two
elements.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">sumBinTree</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">BinTree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span><span class="line"><span class="nf">sumBinTree</span> <span class="ow">=</span> <span class="n">foldBinTree</span> <span class="p">(</span><span class="nf">\</span><span class="n">val</span> <span class="n">res_left</span> <span class="n">res_right</span> <span class="ow">-&gt;</span> <span class="n">val</span> <span class="o">+</span> <span class="n">res_left</span> <span class="o">+</span> <span class="n">res_right</span><span class="p">,</span>
</span><span class="line">                          <span class="mi">0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="nv">$ </span>ghci bintree.hs
</span><span class="line">*Main&gt; bintree
</span><span class="line">Node 1 <span class="o">(</span>Node 2 <span class="o">(</span>Node 3 Leaf Leaf<span class="o">)</span> <span class="o">(</span>Node 3 Leaf Leaf<span class="o">))</span> <span class="o">(</span>Node 2 <span class="o">(</span>Node 3 Leaf Leaf<span class="o">)</span> <span class="o">(</span>Node 3 Leaf Leaf<span class="o">))</span>
</span><span class="line">*Main&gt; sumBinTree bintree
</span><span class="line">19
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>That’s it for now. If you did not understand everything by the end of this
article, don’t panic. It will sink in eventually. Let this rest a day or two,
and then read this article again and you’ll understand folds better. :)</p>
</div>


    <footer>
      <p class="meta">
        
  

<span class="byline author vcard">Posted by <span class="fn"><a rel="author" href="https://plus.google.com/103782975895345685833">Alessandro Vermeulen</a></span></span>

        








  


<time datetime="2009-12-17T00:00:00+00:00" pubdate data-updated="true">Dec 17<span>th</span>, 2009</time>
        


      </p>
      
        <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://alessandrovermeulen.me/2009/12/17/haskell-datatypes-and-folds/" data-via="" data-counturl="http://alessandrovermeulen.me/2009/12/17/haskell-datatypes-and-folds/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
</div>

      
      <p class="meta">
        
          <a class="basic-alignment left" href="/2009/09/08/setting-up-multiple-applications-with-codeigniter/" title="Previous Post: Setting up multiple applications with CodeIgniter">&laquo; Setting up multiple applications with CodeIgniter</a>
        
        
          <a class="basic-alignment right" href="/2010/01/01/doctrine-unable-to-parse-string-unable-to-parse-line-0/" title="next Post: Doctrine: Unable to parse string: Unable to parse line 0 (">Doctrine: Unable to parse string: Unable to parse line 0 ( &raquo;</a>
        
      </p>
    </footer>
  </article>
  
    <section>
      <h1>Comments</h1>
      <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
    </section>
  
  </div>
  
  <aside class="sidebar span3">
    
      <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts" class="unstyled">
    
      <li class="post">
        <a href="/2015/08/31/finaglecon/">FinagleCon</a>
      </li>
    
      <li class="post">
        <a href="/2014/12/04/orchestration-support-announced-on-dockercon/">Orchestration support announced on DockerCon</a>
      </li>
    
      <li class="post">
        <a href="/2014/07/15/notes-on-the-advanced-akka-course/">Notes on the Advanced Akka course</a>
      </li>
    
      <li class="post">
        <a href="/2013/07/13/the-difference-between-shallow-and-deep-embedding/">The difference between shallow and deep embedding</a>
      </li>
    
      <li class="post">
        <a href="/2013/07/08/combining-graphviz-dot-and-tikz-with-dot2tex/">Combining graphviz (dot) and TikZ with dot2tex</a>
      </li>
    
  </ul>
</section>




<section class="tag-cloud">
  <h1>Tags</h1>
  <span class='rank-4'><a href='/tags/xhtml'>xhtml</a></span> <span class='rank-4'><a href='/tags/textmate'>textmate</a></span> <span class='rank-5'><a href='/tags/syntax-highlighting'>syntax highlighting</a></span> <span class='rank-3'><a href='/tags/lhs2tex-hl'>lhs2tex-hl</a></span> <span class='rank-3'><a href='/tags/codeigniter'>codeigniter</a></span> <span class='rank-4'><a href='/tags/doctrine'>doctrine</a></span> <span class='rank-5'><a href='/tags/delphi-2009'>delphi 2009</a></span> <span class='rank-4'><a href='/tags/Graphviz'>Graphviz</a></span> <span class='rank-5'><a href='/tags/Software'>Software</a></span> <span class='rank-4'><a href='/tags/lhs2tex'>lhs2tex</a></span> <span class='rank-5'><a href='/tags/layout'>layout</a></span> <span class='rank-5'><a href='/tags/com'>com</a></span> <span class='rank-5'><a href='/tags/type-algebra'>type algebra</a></span> <span class='rank-5'><a href='/tags/web'>web</a></span> <span class='rank-5'><a href='/tags/uuagc'>uuagc</a></span> <span class='rank-5'><a href='/tags/debian'>debian</a></span> <span class='rank-5'><a href='/tags/Akka'>Akka</a></span> <span class='rank-4'><a href='/tags/partial'>partial</a></span> <span class='rank-4'><a href='/tags/TikZ'>TikZ</a></span> <span class='rank-4'><a href='/tags/Scala'>Scala</a></span> <span class='rank-5'><a href='/tags/Docker'>Docker</a></span> <span class='rank-5'><a href='/tags/Web'>Web</a></span> <span class='rank-5'><a href='/tags/Finagle'>Finagle</a></span> <span class='rank-5'><a href='/tags/colour'>colour</a></span> <span class='rank-5'><a href='/tags/JavaScript'>JavaScript</a></span> <span class='rank-4'><a href='/tags/mvc'>mvc</a></span> <span class='rank-5'><a href='/tags/os-x'>os x</a></span> <span class='rank-4'><a href='/tags/partials'>partials</a></span> <span class='rank-5'><a href='/tags/applescript'>applescript</a></span> <span class='rank-4'><a href='/tags/rss'>rss</a></span> <span class='rank-5'><a href='/tags/html5'>html5</a></span> <span class='rank-5'><a href='/tags/orm'>orm</a></span> <span class='rank-3'><a href='/tags/open-source'>open source</a></span> <span class='rank-5'><a href='/tags/cabal'>cabal</a></span> <span class='rank-5'><a href='/tags/Haskell-platform'>Haskell platform</a></span> <span class='rank-1'><a href='/tags/Haskell'>Haskell</a></span> <span class='rank-5'><a href='/tags/attribute-grammars'>attribute grammars</a></span> <span class='rank-5'><a href='/tags/hackage'>hackage</a></span> <span class='rank-4'><a href='/tags/LaTeX'>LaTeX</a></span> <span class='rank-4'><a href='/tags/fold'>fold</a></span> <span class='rank-5'><a href='/tags/lenny'>lenny</a></span> <span class='rank-4'><a href='/tags/css'>css</a></span> <span class='rank-4'><a href='/tags/php'>php</a></span> <span class='rank-5'><a href='/tags/ghc'>ghc</a></span> 
</section>
<section>
  <h1>About Me</h1>
  <p>Alessandro Vermeulen is a Functional Programming enthousiast and Computer Sciences MSc
     alumnus from Utrecht University. His thesis was on incremental evaluation of Haskell programs.</p>
</section>
<section>
  <h1>Blogroll</h1>
  <ul class="unstyled">
    <li class="nav-header">Friends</li>
    <li><a href="http://blog.timmybankers.nl">Tim Soethout</a></li>
    <li><a href="https://thijsalkema.de/blog/">Thijs Alkemade</a></li>
    <li><a href="http://www.norm2782.com/">Jurriën Stutterheim</a></li>
  </ul>

  <ul class="unstyled">
    <li class="nav-header">Interesting Companies</li>
    <li><a href="https://typesafe.com" rel="nofollow">Typesafe</a></li>
    <li><a href="http://www.binksoftware.nl/" rel="nofollow">BINK software B.V.</a></li>
  </ul>

  <ul class="unstyled">
    <li class="nav-header">Personal</li>
    <li><a href="http://www.linkedin.com/in/alessandrovermeulen" rel="nofollow">LinkedIn</a></li>
  </ul>
</section>

    
  </aside>
  
</div>
      </div>
    </div>
    <footer role="contentinfo" id="pagefooter"><p>
  Copyright &copy; 2015 - Alessandro Vermeulen -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>
<script src="http://hyphenator.googlecode.com/svn/tags/Version%203.2.0/Hyphenator.js?bm=true" type="text/javascript"></script>
</footer>
    

<script type="text/javascript">
      var disqus_shortname = 'alessandrovermeulen';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://alessandrovermeulen.me/2009/12/17/haskell-datatypes-and-folds/';
        var disqus_url = 'http://alessandrovermeulen.me/2009/12/17/haskell-datatypes-and-folds/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>
<!-- <script type="text/javascript">
$(document).ready(function() {
  $('#disqus_thread').disqus({
    domain:     "alessandrovermeulen",
    title:      document.title,
    developer:  window.location.hostname == "localhost" ? 1 : 0,
    show_count: true,
    prettify:   true,
    markdown:   true,
    //iframe_css: "http://somewhere.com/stylesheets/disqus.css",
    ready: function() {
      // this is when your disqus comments finally load
      console.log("Comment count: " + $.disqus.commentCount().toString());
      console.log("Reaction count: " + $.disqus.reactionCount().toString());
    },
    added: function(comments) {
      // do something with the newly added comment divs.
    },
    edit: function(textarea) {
      // called when someone clicks the "reply" button.
    }
  });
});
</script> -->





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





  </section>

  
  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
    ga('create', 'UA-9190312-1', 'auto');
    ga('send', 'pageview');
  </script>


  <script src="/javascripts/modernizr-2.0.js" type="text/javascript"></script>
  <script src="/javascripts/jquery-1.10.2.min.js" type="text/javascript"></script>
  <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
  <script src="/javascripts/photography.js" type="text/javascript"></script>
  <!-- mathjax config similar to math.stackexchange -->
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$', '$'] ],
      displayMath: [ ['$$', '$$']],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    messageStyle: "none",
    "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
  });
  </script>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

</body>
</html>
